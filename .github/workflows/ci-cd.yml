name: Build, Test & Deploy to Azure AKS (Helm + HPA)

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read
  id-token: write
  security-events: write

env:
  NODE_VERSION: '22.x'
  TERRAFORM_VERSION: '1.9.0'
  BACKEND_RG: tf-backend-rg
  TF_VAR_PROJECT_NAME: 'devops-portfolio'
  TF_VAR_ENVIRONMENT: 'prod'
  TF_VAR_LOCATION: 'eastus'
  NAMESPACE: production
  HELM_RELEASE_NAME: portfolio-prod

# =======================================================
# JOB 1: Code Quality & Security
# =======================================================
jobs:
  code-quality:
    name: ðŸ” Code Quality & Security
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - run: npm ci
      
      - name: Run Linter
        run: npm run lint || true
        continue-on-error: true

      - name: Security Scan with Trivy
        uses: aquasecurity/trivy-action@master
        continue-on-error: true
        with:
          scan-type: fs
          scan-ref: .
          format: sarif
          output: trivy-results.sarif

      - uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: trivy-results.sarif

# =======================================================
# JOB 2: Build & Test
# =======================================================
  build-test:
    name: ðŸ—ï¸ Build & Test
    runs-on: ubuntu-latest
    needs: code-quality

    outputs:
      image-tag: ${{ steps.tag.outputs.tag }}

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - run: npm ci
      
      - name: Run Tests
        run: npm test || true
        continue-on-error: true
        
      - name: Build Application
        run: npm run build

      - id: tag
        run: echo "tag=$(echo $GITHUB_SHA | cut -c1-7)" >> $GITHUB_OUTPUT

# =======================================================
# JOB 3: Setup Terraform Backend
# =======================================================
  setup-backend:
    name: ðŸ—„ï¸ Setup Terraform Backend
    runs-on: ubuntu-latest
    needs: build-test

    outputs:
      storage_account_name: ${{ steps.backend.outputs.storage_account_name }}

    steps:
      - uses: actions/checkout@v4

      - uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Create Backend Storage
        id: backend
        run: |
          set -e

          RG="${{ env.BACKEND_RG }}"
          LOCATION="${{ env.TF_VAR_LOCATION }}"
          CONTAINER="tfstate"

          STORAGE="tfstate$(echo devopsportfolio | tr -cd 'a-z0-9' | cut -c1-10)$(date +%s | tail -c 6)"

          az group create --name "$RG" --location "$LOCATION" --output none

          EXISTING=$(az storage account list \
            --resource-group "$RG" \
            --query "[?starts_with(name, 'tfstate')].name" -o tsv | head -n1)

          if [ -z "$EXISTING" ]; then
            az storage account create \
              --name "$STORAGE" \
              --resource-group "$RG" \
              --sku Standard_LRS \
              --min-tls-version TLS1_2 \
              --allow-blob-public-access false \
              --output none
            FINAL="$STORAGE"
          else
            FINAL="$EXISTING"
          fi

          az storage container create \
            --name "$CONTAINER" \
            --account-name "$FINAL" \
            --auth-mode login \
            --output none || true

          echo "storage_account_name=$FINAL" >> $GITHUB_OUTPUT

# =======================================================
# JOB 4: Terraform Deploy
# =======================================================
  terraform-deploy:
    name: ðŸ—ï¸ Terraform Azure Infra
    runs-on: ubuntu-latest
    needs: setup-backend

    outputs:
      acr_name: ${{ steps.tfout.outputs.acr_name }}
      acr_login_server: ${{ steps.tfout.outputs.acr_login_server }}
      aks_name: ${{ steps.tfout.outputs.aks_name }}
      aks_rg: ${{ steps.tfout.outputs.aks_rg }}

    steps:
      - uses: actions/checkout@v4

      - uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Terraform Init
        run: |
          cd terraform
          terraform init \
            -backend-config="resource_group_name=${{ env.BACKEND_RG }}" \
            -backend-config="storage_account_name=${{ needs.setup-backend.outputs.storage_account_name }}" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=infra.tfstate"
        env:
          ARM_CLIENT_ID: ${{ fromJSON(secrets.AZURE_CREDENTIALS).clientId }}
          ARM_CLIENT_SECRET: ${{ fromJSON(secrets.AZURE_CREDENTIALS).clientSecret }}
          ARM_SUBSCRIPTION_ID: ${{ fromJSON(secrets.AZURE_CREDENTIALS).subscriptionId }}
          ARM_TENANT_ID: ${{ fromJSON(secrets.AZURE_CREDENTIALS).tenantId }}

      - name: Terraform Plan
        run: |
          cd terraform
          terraform plan -input=false
        env:
          ARM_CLIENT_ID: ${{ fromJSON(secrets.AZURE_CREDENTIALS).clientId }}
          ARM_CLIENT_SECRET: ${{ fromJSON(secrets.AZURE_CREDENTIALS).clientSecret }}
          ARM_SUBSCRIPTION_ID: ${{ fromJSON(secrets.AZURE_CREDENTIALS).subscriptionId }}
          ARM_TENANT_ID: ${{ fromJSON(secrets.AZURE_CREDENTIALS).tenantId }}
          TF_VAR_project_name: ${{ env.TF_VAR_PROJECT_NAME }}
          TF_VAR_environment: ${{ env.TF_VAR_ENVIRONMENT }}
          TF_VAR_location: ${{ env.TF_VAR_LOCATION }}

      - name: Terraform Apply
        run: |
          cd terraform
          terraform apply -auto-approve -input=false
        env:
          ARM_CLIENT_ID: ${{ fromJSON(secrets.AZURE_CREDENTIALS).clientId }}
          ARM_CLIENT_SECRET: ${{ fromJSON(secrets.AZURE_CREDENTIALS).clientSecret }}
          ARM_SUBSCRIPTION_ID: ${{ fromJSON(secrets.AZURE_CREDENTIALS).subscriptionId }}
          ARM_TENANT_ID: ${{ fromJSON(secrets.AZURE_CREDENTIALS).tenantId }}
          TF_VAR_project_name: ${{ env.TF_VAR_PROJECT_NAME }}
          TF_VAR_environment: ${{ env.TF_VAR_ENVIRONMENT }}
          TF_VAR_location: ${{ env.TF_VAR_LOCATION }}

      - name: Extract Outputs
        id: tfout
        run: |
          cd terraform
          echo "acr_name=$(terraform output -raw acr_name)" >> $GITHUB_OUTPUT
          echo "acr_login_server=$(terraform output -raw acr_login_server)" >> $GITHUB_OUTPUT
          echo "aks_name=$(terraform output -raw aks_cluster_name)" >> $GITHUB_OUTPUT
          echo "aks_rg=$(terraform output -raw aks_rg)" >> $GITHUB_OUTPUT
        env:
          ARM_CLIENT_ID: ${{ fromJSON(secrets.AZURE_CREDENTIALS).clientId }}
          ARM_CLIENT_SECRET: ${{ fromJSON(secrets.AZURE_CREDENTIALS).clientSecret }}
          ARM_SUBSCRIPTION_ID: ${{ fromJSON(secrets.AZURE_CREDENTIALS).subscriptionId }}
          ARM_TENANT_ID: ${{ fromJSON(secrets.AZURE_CREDENTIALS).tenantId }}
          TF_VAR_project_name: ${{ env.TF_VAR_PROJECT_NAME }}
          TF_VAR_environment: ${{ env.TF_VAR_ENVIRONMENT }}
          TF_VAR_location: ${{ env.TF_VAR_LOCATION }}

# =======================================================
# JOB 5: Docker Build & Push
# =======================================================
  docker-build-push:
    name: ðŸ³ Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: terraform-deploy

    outputs:
      image-uri: ${{ steps.push.outputs.image }}

    steps:
      - uses: actions/checkout@v4

      - uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - run: az acr login --name "${{ needs.terraform-deploy.outputs.acr_name }}"

      - name: Build and Push Docker Images
        id: push
        run: |
          TAG=$(echo $GITHUB_SHA | cut -c1-7)
          IMAGE="${{ needs.terraform-deploy.outputs.acr_login_server }}/portfolio-website:${TAG}"

          docker build -t "$IMAGE" -t "${IMAGE%:*}:latest" .
          docker push "$IMAGE"
          docker push "${IMAGE%:*}:latest"

          echo "image=$IMAGE" >> $GITHUB_OUTPUT

# =======================================================
# JOB 6: Deploy to AKS (Helm + HPA) - UPDATED
# =======================================================
  deploy-to-aks:
    name: ðŸš€ Deploy to AKS (Helm)
    runs-on: ubuntu-latest
    needs: [terraform-deploy, docker-build-push]

    steps:
      - uses: actions/checkout@v4

      - uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS Credentials
        run: |
          az aks get-credentials \
            --resource-group "${{ needs.terraform-deploy.outputs.aks_rg }}" \
            --name "${{ needs.terraform-deploy.outputs.aks_name }}" \
            --overwrite-existing

      - uses: azure/setup-helm@v4

      - name: Create Production Namespace
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create or Update ACR Secret
        run: |
          # Get ACR credentials
          ACR_USERNAME=$(az acr credential show \
            --name "${{ needs.terraform-deploy.outputs.acr_name }}" \
            --query "username" -o tsv)
          ACR_PASSWORD=$(az acr credential show \
            --name "${{ needs.terraform-deploy.outputs.acr_name }}" \
            --query "passwords[0].value" -o tsv)
          
          # Delete existing secret if it exists
          kubectl delete secret acr-secret \
            -n ${{ env.NAMESPACE }} \
            --ignore-not-found=true
          
          # Create new secret
          kubectl create secret docker-registry acr-secret \
            --docker-server="${{ needs.terraform-deploy.outputs.acr_login_server }}" \
            --docker-username="$ACR_USERNAME" \
            --docker-password="$ACR_PASSWORD" \
            -n ${{ env.NAMESPACE }}

      - name: Helm Deploy
        run: |
          IMAGE="${{ needs.docker-build-push.outputs.image-uri }}"
          
          echo "Deploying image: $IMAGE"
          echo "Repository: ${IMAGE%:*}"
          echo "Tag: ${IMAGE##*:}"

          # Start deployment in background so we can monitor
          helm upgrade --install ${{ env.HELM_RELEASE_NAME }} ./helm/portfolio \
            -n ${{ env.NAMESPACE }} \
            -f helm/portfolio/values-prod.yaml \
            --set image.repository="${IMAGE%:*}" \
            --set image.tag="${IMAGE##*:}" \
            --wait \
            --timeout 10m \
            --debug &
          
          HELM_PID=$!
          
          # Monitor deployment progress
          sleep 30
          for i in {1..20}; do
            echo ""
            echo "=== Deployment Check $i/20 ==="
            kubectl get pods -n ${{ env.NAMESPACE }} -l app.kubernetes.io/name=portfolio
            
            POD_NAME=$(kubectl get pods -n ${{ env.NAMESPACE }} -l app.kubernetes.io/name=portfolio -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
            if [ ! -z "$POD_NAME" ]; then
              POD_STATUS=$(kubectl get pod $POD_NAME -n ${{ env.NAMESPACE }} -o jsonpath='{.status.phase}')
              echo "Pod Status: $POD_STATUS"
              
              # Check for image pull issues
              if kubectl get pod $POD_NAME -n ${{ env.NAMESPACE }} -o jsonpath='{.status.containerStatuses[0].state.waiting.reason}' 2>/dev/null | grep -q "ImagePullBackOff\|ErrImagePull"; then
                echo "âŒ IMAGE PULL ERROR DETECTED!"
                kubectl describe pod $POD_NAME -n ${{ env.NAMESPACE }} | grep -A 10 "Events:"
                kill $HELM_PID 2>/dev/null || true
                exit 1
              fi
            fi
            
            # Check if helm finished
            if ! kill -0 $HELM_PID 2>/dev/null; then
              wait $HELM_PID
              exit $?
            fi
            
            sleep 15
          done
          
          # Wait for helm to finish
          wait $HELM_PID

      - name: Wait for Deployment Readiness
        run: |
          echo "Looking for deployment..."
          kubectl get deployments -n ${{ env.NAMESPACE }}
          
          # Find the actual deployment name
          DEPLOYMENT_NAME=$(kubectl get deployments -n ${{ env.NAMESPACE }} \
            -l app.kubernetes.io/instance=${{ env.HELM_RELEASE_NAME }} \
            -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          
          if [ -z "$DEPLOYMENT_NAME" ]; then
            echo "âŒ No deployment found with label app.kubernetes.io/instance=${{ env.HELM_RELEASE_NAME }}"
            echo "Available deployments:"
            kubectl get deployments -n ${{ env.NAMESPACE }} -o wide
            exit 1
          fi
          
          echo "Found deployment: $DEPLOYMENT_NAME"
          kubectl rollout status deployment/$DEPLOYMENT_NAME \
            -n ${{ env.NAMESPACE }} \
            --timeout=5m

      - name: Verify Deployment
        run: |
          echo "=== Deployment Status ==="
          kubectl get deployments -n ${{ env.NAMESPACE }}
          
          echo ""
          echo "=== Pods Status ==="
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide
          
          echo ""
          echo "=== Services ==="
          kubectl get svc -n ${{ env.NAMESPACE }}
          
          echo ""
          echo "=== Ingress ==="
          kubectl get ingress -n ${{ env.NAMESPACE }}
          
          echo ""
          echo "=== HPA Status ==="
          kubectl get hpa -n ${{ env.NAMESPACE }}

      - name: Get Application URL
        run: |
          echo "=== ðŸŽ‰ Application Deployed Successfully ==="
          INGRESS_HOST=$(kubectl get ingress -n ${{ env.NAMESPACE }} \
            -o jsonpath='{.items[0].spec.rules[0].host}' 2>/dev/null || echo "N/A")
          echo "Application URL: https://${INGRESS_HOST}"
          echo ""
          echo "ðŸ“Š Deployment Details:"
          echo "  - Image: ${{ needs.docker-build-push.outputs.image-uri }}"
          echo "  - Namespace: ${{ env.NAMESPACE }}"
          echo "  - Release: ${{ env.HELM_RELEASE_NAME }}"

      - name: Debug on Failure
        if: failure()
        run: |
          echo "=== âŒ Deployment Failed - Debugging Information ==="
          echo ""
          echo "=== Pod Status ==="
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide
          
          echo ""
          echo "=== All Deployments ==="
          kubectl get deployments -n ${{ env.NAMESPACE }}
          
          echo ""
          echo "=== Recent Events ==="
          kubectl get events -n ${{ env.NAMESPACE }} \
            --sort-by='.lastTimestamp' | tail -30
          
          echo ""
          echo "=== Deployment Description ==="
          # Find actual deployment name dynamically
          DEPLOYMENT_NAME=$(kubectl get deployments -n ${{ env.NAMESPACE }} \
            -l app.kubernetes.io/instance=${{ env.HELM_RELEASE_NAME }} \
            -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          
          if [ ! -z "$DEPLOYMENT_NAME" ]; then
            kubectl describe deployment $DEPLOYMENT_NAME -n ${{ env.NAMESPACE }} || true
          else
            echo "No deployment found with instance label ${{ env.HELM_RELEASE_NAME }}"
          fi
          
          echo ""
          echo "=== Pod Logs ==="
          POD_NAME=$(kubectl get pods -n ${{ env.NAMESPACE }} \
            -l app.kubernetes.io/name=portfolio \
            -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          
          if [ ! -z "$POD_NAME" ]; then
            echo "Logs from pod: $POD_NAME"
            kubectl logs $POD_NAME -n ${{ env.NAMESPACE }} --tail=100 || true
            
            echo ""
            echo "=== Previous Pod Logs (if crashed) ==="
            kubectl logs $POD_NAME -n ${{ env.NAMESPACE }} \
              --previous --tail=100 2>/dev/null || echo "No previous logs available"
          else
            echo "No pods found"
          fi
          
          echo ""
          echo "=== Helm Release Status ==="
          helm status ${{ env.HELM_RELEASE_NAME }} -n ${{ env.NAMESPACE }} || true
          
          echo ""
          echo "=== Helm Release History ==="
          helm history ${{ env.HELM_RELEASE_NAME }} -n ${{ env.NAMESPACE }} || true

# =======================================================
# JOB 7: Summary
# =======================================================
  notify:
    name: ðŸ“Š Pipeline Summary
    runs-on: ubuntu-latest
    needs: [code-quality, build-test, setup-backend, terraform-deploy, docker-build-push, deploy-to-aks]
    if: always()

    steps:
      - name: Generate Summary
        run: |
          echo "## ðŸš€ Pipeline Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Code Quality | ${{ needs.code-quality.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Build & Test | ${{ needs.build-test.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Backend Setup | ${{ needs.setup-backend.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Terraform | ${{ needs.terraform-deploy.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Docker | ${{ needs.docker-build-push.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| AKS Deploy | ${{ needs.deploy-to-aks.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.deploy-to-aks.result }}" == "success" ]; then
            echo "### âœ… Deployment Successful!" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Your application has been deployed to AKS." >> $GITHUB_STEP_SUMMARY
          else
            echo "### âŒ Pipeline Failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Check the logs above for detailed error information." >> $GITHUB_STEP_SUMMARY
          fi