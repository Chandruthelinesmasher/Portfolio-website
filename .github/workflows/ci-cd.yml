name: Build, Test & Deploy to Azure AKS (Helm + HPA)

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read
  id-token: write
  security-events: write

env:
  NODE_VERSION: '22.x'
  TERRAFORM_VERSION: '1.9.0'
  BACKEND_RG: tf-backend-rg
  TF_VAR_PROJECT_NAME: 'devops-portfolio'
  TF_VAR_ENVIRONMENT: 'prod'
  TF_VAR_LOCATION: 'eastus'
  NAMESPACE: production
  HELM_RELEASE_NAME: portfolio-prod
  INGRESS_NGINX_VERSION: 'v1.8.1'

# =======================================================
# JOB 1: Code Quality & Security
# =======================================================
jobs:
  code-quality:
    name: Code Quality & Security
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - run: npm ci
      
      - name: Run Linter
        run: npm run lint || true
        continue-on-error: true

      - name: Security Scan with Trivy
        uses: aquasecurity/trivy-action@master
        continue-on-error: true
        with:
          scan-type: fs
          scan-ref: .
          format: sarif
          output: trivy-results.sarif

      - uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: trivy-results.sarif

# =======================================================
# JOB 2: Build & Test
# =======================================================
  build-test:
    name:  Build & Test
    runs-on: ubuntu-latest
    needs: code-quality

    outputs:
      image-tag: ${{ steps.tag.outputs.tag }}

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - run: npm ci
      
      - name: Run Tests
        run: npm test || true
        continue-on-error: true
        
      - name: Build Application
        run: npm run build

      - id: tag
        run: echo "tag=$(echo $GITHUB_SHA | cut -c1-7)" >> $GITHUB_OUTPUT

# =======================================================
# JOB 3: Setup Terraform Backend
# =======================================================
  setup-backend:
    name:  Setup Terraform Backend
    runs-on: ubuntu-latest
    needs: build-test

    outputs:
      storage_account_name: ${{ steps.backend.outputs.storage_account_name }}

    steps:
      - uses: actions/checkout@v4

      - uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Create Backend Storage
        id: backend
        run: |
          set -e

          RG="${{ env.BACKEND_RG }}"
          LOCATION="${{ env.TF_VAR_LOCATION }}"
          CONTAINER="tfstate"

          STORAGE="tfstate$(echo devopsportfolio | tr -cd 'a-z0-9' | cut -c1-10)$(date +%s | tail -c 6)"

          az group create --name "$RG" --location "$LOCATION" --output none

          EXISTING=$(az storage account list \
            --resource-group "$RG" \
            --query "[?starts_with(name, 'tfstate')].name" -o tsv | head -n1)

          if [ -z "$EXISTING" ]; then
            az storage account create \
              --name "$STORAGE" \
              --resource-group "$RG" \
              --sku Standard_LRS \
              --min-tls-version TLS1_2 \
              --allow-blob-public-access false \
              --output none
            FINAL="$STORAGE"
          else
            FINAL="$EXISTING"
          fi

          az storage container create \
            --name "$CONTAINER" \
            --account-name "$FINAL" \
            --auth-mode login \
            --output none || true

          echo "storage_account_name=$FINAL" >> $GITHUB_OUTPUT

# =======================================================
# JOB 4: Terraform Deploy
# =======================================================
  terraform-deploy:
    name:  Terraform Azure Infra
    runs-on: ubuntu-latest
    needs: setup-backend

    outputs:
      acr_name: ${{ steps.tfout.outputs.acr_name }}
      acr_login_server: ${{ steps.tfout.outputs.acr_login_server }}
      aks_name: ${{ steps.tfout.outputs.aks_name }}
      aks_rg: ${{ steps.tfout.outputs.aks_rg }}

    steps:
      - uses: actions/checkout@v4

      - uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Terraform Init
        run: |
          cd terraform
          terraform init \
            -backend-config="resource_group_name=${{ env.BACKEND_RG }}" \
            -backend-config="storage_account_name=${{ needs.setup-backend.outputs.storage_account_name }}" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=infra.tfstate"
        env:
          ARM_CLIENT_ID: ${{ fromJSON(secrets.AZURE_CREDENTIALS).clientId }}
          ARM_CLIENT_SECRET: ${{ fromJSON(secrets.AZURE_CREDENTIALS).clientSecret }}
          ARM_SUBSCRIPTION_ID: ${{ fromJSON(secrets.AZURE_CREDENTIALS).subscriptionId }}
          ARM_TENANT_ID: ${{ fromJSON(secrets.AZURE_CREDENTIALS).tenantId }}

      - name: Terraform Plan
        run: |
          cd terraform
          terraform plan -input=false
        env:
          ARM_CLIENT_ID: ${{ fromJSON(secrets.AZURE_CREDENTIALS).clientId }}
          ARM_CLIENT_SECRET: ${{ fromJSON(secrets.AZURE_CREDENTIALS).clientSecret }}
          ARM_SUBSCRIPTION_ID: ${{ fromJSON(secrets.AZURE_CREDENTIALS).subscriptionId }}
          ARM_TENANT_ID: ${{ fromJSON(secrets.AZURE_CREDENTIALS).tenantId }}
          TF_VAR_project_name: ${{ env.TF_VAR_PROJECT_NAME }}
          TF_VAR_environment: ${{ env.TF_VAR_ENVIRONMENT }}
          TF_VAR_location: ${{ env.TF_VAR_LOCATION }}

      - name: Terraform Apply
        run: |
          cd terraform
          terraform apply -auto-approve -input=false
        env:
          ARM_CLIENT_ID: ${{ fromJSON(secrets.AZURE_CREDENTIALS).clientId }}
          ARM_CLIENT_SECRET: ${{ fromJSON(secrets.AZURE_CREDENTIALS).clientSecret }}
          ARM_SUBSCRIPTION_ID: ${{ fromJSON(secrets.AZURE_CREDENTIALS).subscriptionId }}
          ARM_TENANT_ID: ${{ fromJSON(secrets.AZURE_CREDENTIALS).tenantId }}
          TF_VAR_project_name: ${{ env.TF_VAR_PROJECT_NAME }}
          TF_VAR_environment: ${{ env.TF_VAR_ENVIRONMENT }}
          TF_VAR_location: ${{ env.TF_VAR_LOCATION }}

      - name: Extract Outputs
        id: tfout
        run: |
          cd terraform
          echo "acr_name=$(terraform output -raw acr_name)" >> $GITHUB_OUTPUT
          echo "acr_login_server=$(terraform output -raw acr_login_server)" >> $GITHUB_OUTPUT
          echo "aks_name=$(terraform output -raw aks_cluster_name)" >> $GITHUB_OUTPUT
          echo "aks_rg=$(terraform output -raw aks_rg)" >> $GITHUB_OUTPUT
        env:
          ARM_CLIENT_ID: ${{ fromJSON(secrets.AZURE_CREDENTIALS).clientId }}
          ARM_CLIENT_SECRET: ${{ fromJSON(secrets.AZURE_CREDENTIALS).clientSecret }}
          ARM_SUBSCRIPTION_ID: ${{ fromJSON(secrets.AZURE_CREDENTIALS).subscriptionId }}
          ARM_TENANT_ID: ${{ fromJSON(secrets.AZURE_CREDENTIALS).tenantId }}
          TF_VAR_project_name: ${{ env.TF_VAR_PROJECT_NAME }}
          TF_VAR_environment: ${{ env.TF_VAR_ENVIRONMENT }}
          TF_VAR_location: ${{ env.TF_VAR_LOCATION }}

# =======================================================
# JOB 5: Docker Build & Push
# =======================================================
  docker-build-push:
    name:  Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: terraform-deploy

    outputs:
      image-uri: ${{ steps.push.outputs.image }}

    steps:
      - uses: actions/checkout@v4

      - uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - run: az acr login --name "${{ needs.terraform-deploy.outputs.acr_name }}"

      - name: Build and Push Docker Images
        id: push
        run: |
          TAG=$(echo $GITHUB_SHA | cut -c1-7)
          IMAGE="${{ needs.terraform-deploy.outputs.acr_login_server }}/portfolio-website:${TAG}"

          docker build -t "$IMAGE" -t "${IMAGE%:*}:latest" .
          docker push "$IMAGE"
          docker push "${IMAGE%:*}:latest"

          echo "image=$IMAGE" >> $GITHUB_OUTPUT

# =======================================================
# JOB 6: Setup Ingress Controller (NEW!)
# =======================================================
  setup-ingress-controller:
    name:  Setup Ingress Controller
    runs-on: ubuntu-latest
    needs: terraform-deploy

    steps:
      - uses: actions/checkout@v4

      - uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS Credentials
        run: |
          az aks get-credentials \
            --resource-group "${{ needs.terraform-deploy.outputs.aks_rg }}" \
            --name "${{ needs.terraform-deploy.outputs.aks_name }}" \
            --overwrite-existing

      - name: Check if Ingress Controller Exists
        id: check-ingress
        run: |
          if kubectl get namespace ingress-nginx &>/dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo " Ingress controller namespace exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo " Ingress controller not found"
          fi

      - name: Install Nginx Ingress Controller
        if: steps.check-ingress.outputs.exists == 'false'
        run: |
          echo " Installing Nginx Ingress Controller..."
          kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-${{ env.INGRESS_NGINX_VERSION }}/deploy/static/provider/cloud/deploy.yaml

      - name: Wait for Ingress Controller
        run: |
          echo " Waiting for ingress controller to be ready..."
          kubectl wait --namespace ingress-nginx \
            --for=condition=ready pod \
            --selector=app.kubernetes.io/component=controller \
            --timeout=300s || true
          
          echo ""
          echo " Ingress controller status:"
          kubectl get pods -n ingress-nginx
          kubectl get svc -n ingress-nginx

      - name: Get Ingress External IP
        id: ingress-ip
        run: |
          echo " Waiting for LoadBalancer IP assignment (max 3 minutes)..."
          for i in {1..18}; do
            EXTERNAL_IP=$(kubectl get svc ingress-nginx-controller -n ingress-nginx \
              -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
            
            if [ ! -z "$EXTERNAL_IP" ]; then
              echo " Ingress LoadBalancer IP assigned: $EXTERNAL_IP"
              echo "ingress_ip=$EXTERNAL_IP" >> $GITHUB_OUTPUT
              break
            fi
            
            echo "Attempt $i/18: IP not assigned yet, waiting 10s..."
            sleep 10
          done
          
          if [ -z "$EXTERNAL_IP" ]; then
            echo " LoadBalancer IP not assigned within timeout"
            echo "This is not critical - it may take a few more minutes"
          fi

# =======================================================
# JOB 7: Deploy to AKS (Helm + HPA)
# =======================================================
  deploy-to-aks:
    name:  Deploy to AKS (Helm)
    runs-on: ubuntu-latest
    needs: [terraform-deploy, docker-build-push, setup-ingress-controller]

    steps:
      - uses: actions/checkout@v4

      - uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS Credentials
        run: |
          az aks get-credentials \
            --resource-group "${{ needs.terraform-deploy.outputs.aks_rg }}" \
            --name "${{ needs.terraform-deploy.outputs.aks_name }}" \
            --overwrite-existing

      - uses: azure/setup-helm@v4

      - name: Create Production Namespace
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create or Update ACR Secret
        run: |
          echo " Creating ACR credentials secret..."
          
          # Enable admin user on ACR
          az acr update --name "${{ needs.terraform-deploy.outputs.acr_name }}" --admin-enabled true
          
          # Get ACR credentials
          ACR_USERNAME=$(az acr credential show \
            --name "${{ needs.terraform-deploy.outputs.acr_name }}" \
            --query "username" -o tsv)
          ACR_PASSWORD=$(az acr credential show \
            --name "${{ needs.terraform-deploy.outputs.acr_name }}" \
            --query "passwords[0].value" -o tsv)
          
          echo "ACR Username: $ACR_USERNAME"
          
          # Delete existing secret if it exists
          kubectl delete secret acr-secret \
            -n ${{ env.NAMESPACE }} \
            --ignore-not-found=true
          
          # Create new secret
          kubectl create secret docker-registry acr-secret \
            --docker-server="${{ needs.terraform-deploy.outputs.acr_login_server }}" \
            --docker-username="$ACR_USERNAME" \
            --docker-password="$ACR_PASSWORD" \
            -n ${{ env.NAMESPACE }}
          
          # Verify secret was created
          kubectl get secret acr-secret -n ${{ env.NAMESPACE }} && echo " ACR secret created successfully"

      - name: Helm Deploy
        run: |
          IMAGE="${{ needs.docker-build-push.outputs.image-uri }}"
          
          echo " Deploying image: $IMAGE"
          echo "   Repository: ${IMAGE%:*}"
          echo "   Tag: ${IMAGE##*:}"
          echo ""

          helm upgrade --install ${{ env.HELM_RELEASE_NAME }} ./helm/portfolio \
            -n ${{ env.NAMESPACE }} \
            -f helm/portfolio/values-prod.yaml \
            --set image.repository="${IMAGE%:*}" \
            --set image.tag="${IMAGE##*:}" \
            --wait \
            --timeout 10m \
            --atomic

      - name: Wait for Deployment Readiness
        run: |
          echo " Waiting for deployment to be ready..."
          
          # Find the actual deployment name
          DEPLOYMENT_NAME=$(kubectl get deployments -n ${{ env.NAMESPACE }} \
            -l app.kubernetes.io/instance=${{ env.HELM_RELEASE_NAME }} \
            -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          
          if [ -z "$DEPLOYMENT_NAME" ]; then
            echo " No deployment found with label app.kubernetes.io/instance=${{ env.HELM_RELEASE_NAME }}"
            echo "Available deployments:"
            kubectl get deployments -n ${{ env.NAMESPACE }} -o wide
            exit 1
          fi
          
          echo " Found deployment: $DEPLOYMENT_NAME"
          kubectl rollout status deployment/$DEPLOYMENT_NAME \
            -n ${{ env.NAMESPACE }} \
            --timeout=5m

      - name: Verify Deployment
        run: |
          echo "===  Deployment Status ==="
          kubectl get deployments -n ${{ env.NAMESPACE }}
          
          echo ""
          echo "===  Pods Status ==="
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide
          
          echo ""
          echo "===  Services ==="
          kubectl get svc -n ${{ env.NAMESPACE }}
          
          echo ""
          echo "===  Ingress ==="
          kubectl get ingress -n ${{ env.NAMESPACE }} -o wide
          
          echo ""
          echo "===  HPA Status ==="
          kubectl get hpa -n ${{ env.NAMESPACE }}

      - name: Get Application URL
        id: get-url
        run: |
          echo "===  Application Deployed Successfully ==="
          echo ""
          
          # Get ingress details
          INGRESS_HOST=$(kubectl get ingress -n ${{ env.NAMESPACE }} \
            -o jsonpath='{.items[0].spec.rules[0].host}' 2>/dev/null || echo "")
          INGRESS_IP=$(kubectl get ingress -n ${{ env.NAMESPACE }} \
            -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
          
          # Get ingress controller IP if ingress IP not ready
          if [ -z "$INGRESS_IP" ]; then
            INGRESS_IP=$(kubectl get svc ingress-nginx-controller -n ingress-nginx \
              -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "pending")
          fi
          
          echo " Deployment Details:"
          echo "  - Image: ${{ needs.docker-build-push.outputs.image-uri }}"
          echo "  - Namespace: ${{ env.NAMESPACE }}"
          echo "  - Release: ${{ env.HELM_RELEASE_NAME }}"
          echo ""
          echo " Access Information:"
          echo "  - Hostname: $INGRESS_HOST"
          echo "  - Ingress IP: $INGRESS_IP"
          echo ""
          
          if [ "$INGRESS_IP" != "pending" ] && [ ! -z "$INGRESS_IP" ]; then
            echo " Your application is accessible at:"
            echo "    https://$INGRESS_HOST"
            echo ""
            echo " DNS Configuration:"
            echo "   Configure DNS A record:"
            echo "   $INGRESS_HOST â†’ $INGRESS_IP"
            echo ""
            echo " Quick Test (without DNS):"
            echo "   curl -H \"Host: $INGRESS_HOST\" http://$INGRESS_IP/health"
          else
            echo " Ingress IP is still being assigned..."
            echo "   Check again in 2-3 minutes with:"
            echo "   kubectl get ingress -n ${{ env.NAMESPACE }}"
          fi
          
          # Save to output
          echo "ingress_ip=$INGRESS_IP" >> $GITHUB_OUTPUT
          echo "ingress_host=$INGRESS_HOST" >> $GITHUB_OUTPUT

      - name: Test Application Health
        run: |
          echo " Testing application health..."
          
          # Get pod to test
          POD=$(kubectl get pods -n ${{ env.NAMESPACE }} \
            -l app.kubernetes.io/name=portfolio \
            -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          
          if [ ! -z "$POD" ]; then
            echo "Testing health endpoint on pod: $POD"
            kubectl exec $POD -n ${{ env.NAMESPACE }} -- curl -s http://localhost:8080/health || echo "Health check pending..."
          fi

      - name: Debug on Failure
        if: failure()
        run: |
          echo "===  Deployment Failed - Debugging Information ==="
          echo ""
          echo "=== Pod Status ==="
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide
          
          echo ""
          echo "=== All Deployments ==="
          kubectl get deployments -n ${{ env.NAMESPACE }}
          
          echo ""
          echo "=== Recent Events ==="
          kubectl get events -n ${{ env.NAMESPACE }} \
            --sort-by='.lastTimestamp' | tail -50
          
          echo ""
          echo "=== Deployment Description ==="
          DEPLOYMENT_NAME=$(kubectl get deployments -n ${{ env.NAMESPACE }} \
            -l app.kubernetes.io/instance=${{ env.HELM_RELEASE_NAME }} \
            -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          
          if [ ! -z "$DEPLOYMENT_NAME" ]; then
            kubectl describe deployment $DEPLOYMENT_NAME -n ${{ env.NAMESPACE }} || true
          fi
          
          echo ""
          echo "=== Pod Logs ==="
          POD_NAME=$(kubectl get pods -n ${{ env.NAMESPACE }} \
            -l app.kubernetes.io/name=portfolio \
            -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          
          if [ ! -z "$POD_NAME" ]; then
            echo "Current logs from: $POD_NAME"
            kubectl logs $POD_NAME -n ${{ env.NAMESPACE }} --tail=100 || true
            
            echo ""
            echo "Previous logs (if crashed):"
            kubectl logs $POD_NAME -n ${{ env.NAMESPACE }} --previous --tail=100 2>/dev/null || echo "No previous logs"
          fi
          
          echo ""
          echo "=== Ingress Controller Status ==="
          kubectl get pods -n ingress-nginx
          kubectl get svc -n ingress-nginx
          
          echo ""
          echo "=== Helm Release Status ==="
          helm status ${{ env.HELM_RELEASE_NAME }} -n ${{ env.NAMESPACE }} || true
          helm history ${{ env.HELM_RELEASE_NAME }} -n ${{ env.NAMESPACE }} || true

# =======================================================
# JOB 8: Summary & Notifications
# =======================================================
  notify:
    name:  Pipeline Summary
    runs-on: ubuntu-latest
    needs: [code-quality, build-test, setup-backend, terraform-deploy, docker-build-push, setup-ingress-controller, deploy-to-aks]
    if: always()

    steps:
      - name: Generate Summary
        run: |
          echo "##  Pipeline Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Code Quality | ${{ needs.code-quality.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Build & Test | ${{ needs.build-test.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Backend Setup | ${{ needs.setup-backend.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Terraform | ${{ needs.terraform-deploy.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Docker | ${{ needs.docker-build-push.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Ingress Setup | ${{ needs.setup-ingress-controller.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| AKS Deploy | ${{ needs.deploy-to-aks.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.deploy-to-aks.result }}" == "success" ]; then
            echo "###  Deployment Successful!" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Your application has been deployed to AKS with Ingress Controller." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Next Steps:**" >> $GITHUB_STEP_SUMMARY
            echo "1. Get your Ingress IP: \`kubectl get ingress -n production\`" >> $GITHUB_STEP_SUMMARY
            echo "2. Configure your DNS to point to the Ingress IP" >> $GITHUB_STEP_SUMMARY
            echo "3. Access your application at your configured domain" >> $GITHUB_STEP_SUMMARY
          else
            echo "###  Pipeline Failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Check the logs above for detailed error information." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Common Issues:**" >> $GITHUB_STEP_SUMMARY
            echo "- Port mismatch (check containerPort matches nginx.conf)" >> $GITHUB_STEP_SUMMARY
            echo "- Image pull errors (check ACR credentials)" >> $GITHUB_STEP_SUMMARY
            echo "- Health probe failures (check /health endpoint)" >> $GITHUB_STEP_SUMMARY
          fi
